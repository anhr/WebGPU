/**
 * @module WebGPU
 * @description WebGPU Compute.
 *
 * @author [Andrej Hristoliubov]{@link https://anhr.github.io/AboutMe/}
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.WebGPU={})}(this,function(e){"use strict";
/**
 * @module WebGPU
 * @description [WebGPU]{@link https://gpuweb.github.io/gpuweb/}. GPU Compute on the web.
 * @see [Get started with GPU Compute on the web]{@link https://web.dev/gpu-compute/}
 *
 * @author [Andrej Hristoliubov]{@link https://github.com/anhr}
 *
 * @copyright 2011 Data Arts Team, Google Creative Lab
 *
 * @license under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
*/class s{constructor(l){let c=null;!async function r(){if(s.isSupportWebGPU()){var e=await navigator.gpu.requestAdapter();if(!e)return console.error("No WebGPU adapters found."),!1;(c=await e.requestDevice()).lost.then(e=>{console.error("WebGPU device was lost: "+e.message),c=null,"destroyed"!=e.reason&&r()});{const n=l.input;let s,i;const f={param:0,max:0};function a(a,t){let s=0;const o=[];Object.keys(a).forEach(e=>{var r=a[e];"number"==typeof r?r%1==0||t!==Uint32Array?(s+=t.BYTES_PER_ELEMENT,o.push(r)):console.error("WebGPU: Invalid "+e+" = "+r+" parameter type. "+(t===Uint32Array?"Integer":"Float")+" is allowed only."):console.error("WebGPU: Invalid param: "+r)}),a.paramBuffer=c.createBuffer({size:s,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),c.queue.writeBuffer(a.paramBuffer,0,new t(o)),a.data=o}n&&(n.matrices&&n.matrices.forEach(e=>{const r=[e.length,e[0].length];e.forEach(e=>e.forEach(e=>r.push(e))),e.matrix=new Float32Array(r),e.gpuBuffer=c.createBuffer({mappedAtCreation:!0,size:e.matrix.byteLength,usage:GPUBufferUsage.STORAGE}),new Float32Array(e.gpuBuffer.getMappedRange()).set(e.matrix),e.gpuBuffer.unmap()}),n.params)&&Object.keys(n.params).forEach(e=>{switch(e){case"f32":a(n.params[e],Float32Array);break;case"u32":a(n.params[e],Uint32Array);break;default:console.error('WebGPU: Invalid input.params "'+e+'" key.')}}),l.results.forEach((e,r)=>{e.out?void 0!==e.phase&&e.phase>f.max&&(f.max=e.phase):console.error("WebGPU: settings.results["+r+"].out is undefined.")}),0<f.max&&(f.paramBuffer=c.createBuffer({size:Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),c.queue.writeBuffer(f.paramBuffer,0,new Uint32Array([f.param]))),l.results&&l.results.forEach(e=>{void 0===e.type&&(e.type=Float32Array);var r=e.type.BYTES_PER_ELEMENT*e.count;r?c.limits.maxBufferSize<r?console.error("WebGPU: GPUDevice buffer size = "+r+" is limited to "+c.limits.maxBufferSize):e.buffer=c.createBuffer({size:r,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}):console.error('WebGPU: "count" key is not defined in the settings.results item.')});const u=[],p=[];let r=0;if(n){if(n.matrices)for(var t=0;t<n.matrices.length;t++)u.push({binding:r,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),p.push({binding:r,resource:{buffer:n.matrices[t].gpuBuffer}}),r++;n.params&&Object.keys(n.params).forEach(e=>{switch(e){case"f32":case"u32":u.push({binding:r,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),p.push({binding:r,resource:{buffer:n.params[e].paramBuffer}}),r++;break;default:console.error('WebGPU: Invalid input.params "'+e+'" key.')}})}async function o(e){l.shaderCodeText&&(e=l.shaderCodeText(e));var r,a,e=c.createShaderModule({code:e});const u=c.createComputePipeline({layout:c.createPipelineLayout({bindGroupLayouts:[s]}),compute:{module:e,entryPoint:"main"}});function t(){const r=c.createCommandEncoder();var e=r.beginComputePass();e.setPipeline(u),e.setBindGroup(0,i);let a=[];n&&n.matrices?n.matrices.forEach((e,r)=>a.push(Math.ceil(e.matrix[r]/8))):l.workgroupCount?a=l.workgroupCount:a.push(1);var t=a[0],s=a[1],o=a[3];return e.dispatchWorkgroups(t,s,o),e.end(),l.results&&l.results.forEach(e=>{e.gpuReadBuffer=c.createBuffer({size:e.buffer.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),r.copyBufferToBuffer(e.buffer,0,e.gpuReadBuffer,0,e.buffer.size)}),r.finish()}if(c.queue.submit([t()]),l.results)for(;;){for(let e=0;e<l.results.length;e++)r=e,a=void 0,await((a=l.results[r]).out?(a.phase||0)!==f.param||(await a.gpuReadBuffer.mapAsync(GPUMapMode.READ),!a.out(a.gpuReadBuffer.getMappedRange())):!console.error("WebGPU: settings.results["+r+"].out is undefined."));if(f.param++,f.param>f.max)break;c.queue.writeBuffer(f.paramBuffer,0,new Uint32Array([f.param])),c.queue.submit([t()])}}l.results&&l.results.forEach(e=>{u.push({binding:r,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),p.push({binding:r,resource:{buffer:e.buffer}}),r++}),0<f.max&&(u.push({binding:r,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),p.push({binding:r,resource:{buffer:f.paramBuffer}}),r++),s=c.createBindGroupLayout({entries:u}),i=c.createBindGroup({layout:s,entries:p}),(e=l.shaderCode)?o(e):fetch(l.shaderCodeFile).then(e=>{if(e.ok)return e.text();throw new Error(`Load "${e.url}" ${e.statusText}. Status = `+e.status)}).then(e=>{o(e)}).catch(e=>{console.error(e)})}}else console.error("WebGPU: User agent doesn't support WebGPU. WebGPU is available for now in Chrome Canary https://www.google.com/intl/ru/chrome/canary/ on desktop behind an experimental flag. You can enable it at chrome://flags/#enable-unsafe-webgpu. The API is constantly changing and currently unsafe. As GPU sandboxing isn't implemented yet for the WebGPU API, it is possible to read GPU data for other processes! Don't browse the web with it enabled.")}()}}s.isSupportWebGPU=function(){return"gpu"in navigator},s.out2Matrix=function(e,i={}){const n=new(i.type||Float32Array)(e),r=[];let f,p;const l=i.size;return f=l?(p=l.length,0):(p=n[0])+1,function r(a,t){if(!(a>p)){var s=l?l[a-1]:n[a];for(let e=0;e<s;e++){var o=[];if(a===p-1){var u=l?l[p-1]:n[p];for(let e=0;e<u;e++){if(f>=n.length)return void console.error("WebGPU.out2Matrix: out of the index range of the out array. "+f);o.push(n[f]),f++}i.push&&i.push(o)}else r(a+1,o);i.push&&!i.returnMatrix||t.push(o)}}}(1,r),r},s.gui=class{constructor(e,r){if(e.boOptions){var a=e.dat.gui;if(a){e=e.getLanguageCode;const t={webGPU:"WebGPU",webGPUTitle:"WebGPU settings"};e=e();"ru"===e?t.webGPUTitle="Настройки WebGPU":void 0!==guiParams.lang&&guiParams.lang.languageCode==e&&Object.keys(guiParams.lang).forEach(function(e){void 0!==t[e]&&(t[e]=guiParams.lang[e])});e=a.addFolder(t.webGPU);r.folderNameAndTitle(e,t.webGPU,t.webGPUTitle)}}else console.error("WebGPU.gui: call options = new Options( options ) first")}},e.default=s,Object.defineProperty(e,"__esModule",{value:!0})});
