function myRequest(e){if(this.loadXMLDoc=function(){var e;if(window.XMLHttpRequest){if(!(e=new XMLHttpRequest))throw"new XMLHttpRequest() failed!"}else{if(!window.ActiveXObject)throw"myRequest.loadXMLDoc(...) failed!";if(!(e=this.NewActiveXObject()))throw"NewActiveXObject() failed!"}return e},this.NewActiveXObject=function(){try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(e){}try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}return r('This browser does not support XMLHttpRequest. Probably, your security settings do not allow Web sites to use ActiveX controls installed on your computer. Refresh your Web page to find out the current status of your Web page or enable the "Initialize and script ActiveX controls not marked as safe" and "Run Active X controls and plug-ins" of the Security settings of the Internet zone of your browser.'),null},this.XMLHttpRequestStart=function(e,t){this.XMLHttpRequestStop(),this.req.onreadystatechange=e,"onerror"in this.req&&(this.req.onerror=function(e){r("XMLHttpRequest error. url: "+this.url)}),this.XMLHttpRequestReStart(t)},this.getUrl=function(){return void 0!==this.url&&null!=this.url||r("XMLHttpRequest: Invalid url: "+this.url),this.url+(this.params?this.params:"")},this.XMLHttpRequestReStart=function(e){try{if(void 0===e&&(e=!0),this.req.open("GET",this.getUrl(),e),e){"timeout"in this.req&&(this.req.timeout=9e4),"ontimeout"in this.req?this.req.ontimeout=function(){r("XMLHttpRequest timeout")}:(clearTimeout(this.timeout_id_SendReq),this.timeout_id_SendReq=setTimeout(function(){r("XMLHttpRequest timeout 2")},9e4))}this.req.send(null)}catch(e){r(e.message+" url: "+this.url)}},this.XMLHttpRequestStop=function(){null!=this.req&&this.req.abort()},this.ProcessReqChange=function(e){var t=this.req;switch(t.readyState){case 4:if("unknown"==typeof t.status)return consoleError('typeof XMLHttpRequest status == "unknown"'),!0;if(200==t.status)return clearTimeout(this.timeout_id_SendReq),e(this);r("Invalid XMLHttpRequest status : "+t.status+" url: "+this.url);break;case 1:case 2:case 3:break;case 0:default:throw"processReqChange(); req.readyState = "+t.readyState}return!0},this.processStatus200Error=function(){var e=this.GetElementText("error",!0);return!!e&&(r(e),!0)},this.GetElementText=function(e,t){var s=this.req;if(!s.responseXML)return 1!=t&&r("GetXMLElementText(xmlhttp, "+e+"); xmlhttp.responseXML is null.\nxmlhttp.responseText:\n"+s.responseText),null;var n=s.responseXML.getElementsByTagName(e);if(0==n.length)return 1!=t&&r('GetXMLElementText(xmlhttp, "'+e+'"); element.length == '+n.length),"";for(var a="",o=0;o<n.length;o++)if(void 0===n[o].textContent){if(void 0===n[o].text)return r("GetXMLElementText(xmlhttp, "+e+"); element["+o+"].text) == undefined"),"";""!=a&&(a+=" "),a+=n[o].text}else a+=n[o].textContent;return a},e.data)this.req=e.data.req,this.url=e.data.url,this.params=e.data.params;else try{this.req=this.loadXMLDoc()}catch(e){var t;return t=void 0===e.message?e:e.message,void r("Your browser is too old and is not compatible with our site.\n\n"+window.navigator.appName+" "+window.navigator.appVersion+"\n\n"+t)}function r(t){console.error(t),e.onerror(t)}this.req||consoleError("Invalid myRequest.req: "+this.req)}function sync(e,t){(t=t||{}).onload=t.onload||function(){},t.onerror=t.onerror||function(){};var r,s=new myRequest(t);return s.url=e,s.XMLHttpRequestStart(function(){s.ProcessReqChange(function(s){s.processStatus200Error()||(r=s.req.responseText,t.onload(r,e))})},void 0!==t.async),r}function async(e,t){t.async=!0,sync(e,t)}var loadFile={sync:sync,async:async};class WebGPU{constructor(e){let t=null;!async function r(){if(!WebGPU.isSupportWebGPU())return void console.error("WebGPU: User agent doesn't support WebGPU. WebGPU is available for now in Chrome Canary https://www.google.com/intl/ru/chrome/canary/ on desktop behind an experimental flag. You can enable it at chrome://flags/#enable-unsafe-webgpu. The API is constantly changing and currently unsafe. As GPU sandboxing isn't implemented yet for the WebGPU API, it is possible to read GPU data for other processes! Don't browse the web with it enabled.");const s=await navigator.gpu.requestAdapter();if(!s)return console.error("No WebGPU adapters found."),!1;(t=await s.requestDevice()).lost.then(e=>{console.error(`WebGPU device was lost: ${e.message}`),t=null,"destroyed"!=e.reason&&r()}),function(){const r=e.input;let s,n;const a={param:0,max:0};if(r&&(r.matrices&&r.matrices.forEach(e=>{const r=[e.length,e[0].length];e.forEach(e=>e.forEach(e=>r.push(e))),e.matrix=new Float32Array(r),e.gpuBuffer=t.createBuffer({mappedAtCreation:!0,size:e.matrix.byteLength,usage:GPUBufferUsage.STORAGE}),new Float32Array(e.gpuBuffer.getMappedRange()).set(e.matrix),e.gpuBuffer.unmap()}),r.params)){function o(e,r){let s=0;const n=[];Object.keys(e).forEach(t=>{let a=e[t];if("number"==typeof a){const e=a%1==0;if(!e&&r===Uint32Array)return void console.error("WebGPU: Invalid "+t+" = "+a+" parameter type. "+(r===Uint32Array?"Integer":"Float")+" is allowed only.");s+=r.BYTES_PER_ELEMENT,n.push(a)}else console.error("WebGPU: Invalid param: "+a)}),e.paramBuffer=t.createBuffer({size:s,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),t.queue.writeBuffer(e.paramBuffer,0,new r(n)),e.data=n}Object.keys(r.params).forEach(e=>{switch(e){case"f32":o(r.params[e],Float32Array);break;case"u32":o(r.params[e],Uint32Array);break;default:console.error('WebGPU: Invalid input.params "'+e+'" key.')}})}e.results.forEach((e,t)=>{e.out?void 0!==e.phase&&e.phase>a.max&&(a.max=e.phase):console.error("WebGPU: settings.results["+t+"].out is undefined.")}),a.max>0&&(a.paramBuffer=t.createBuffer({size:Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),t.queue.writeBuffer(a.paramBuffer,0,new Uint32Array([a.param]))),e.results&&e.results.forEach(e=>{void 0===e.type&&(e.type=Float32Array);const r=e.type.BYTES_PER_ELEMENT*e.count;r?t.limits.maxBufferSize<r?console.error("WebGPU: GPUDevice buffer size = "+r+" is limited to "+t.limits.maxBufferSize):e.buffer=t.createBuffer({size:r,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}):console.error('WebGPU: "count" key is not defined in the settings.results item.')});const i=[],u=[];let f=0;if(r){if(r.matrices)for(var c=0;c<r.matrices.length;c++)i.push({binding:f,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),u.push({binding:f,resource:{buffer:r.matrices[c].gpuBuffer}}),f++;r.params&&Object.keys(r.params).forEach(e=>{switch(e){case"f32":case"u32":i.push({binding:f,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),u.push({binding:f,resource:{buffer:r.params[e].paramBuffer}}),f++;break;default:console.error('WebGPU: Invalid input.params "'+e+'" key.')}})}e.results&&e.results.forEach(e=>{i.push({binding:f,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),u.push({binding:f,resource:{buffer:e.buffer}}),f++}),a.max>0&&(i.push({binding:f,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),u.push({binding:f,resource:{buffer:a.paramBuffer}}),f++),s=t.createBindGroupLayout({entries:i}),n=t.createBindGroup({layout:s,entries:u});const l=e.shaderCode;async function p(o){e.shaderCodeText&&(o=e.shaderCodeText(o));const i=t.createShaderModule({code:o}),u=t.createComputePipeline({layout:t.createPipelineLayout({bindGroupLayouts:[s]}),compute:{module:i,entryPoint:"main"}});function f(){const s=t.createCommandEncoder(),a=s.beginComputePass();a.setPipeline(u),a.setBindGroup(0,n);let o=[];r&&r.matrices?r.matrices.forEach((e,t)=>o.push(Math.ceil(e.matrix[t]/8))):e.workgroupCount?o=e.workgroupCount:o.push(1);const i=o[0],f=o[1],c=o[3];return a.dispatchWorkgroups(i,f,c),a.end(),e.results&&e.results.forEach(e=>{e.gpuReadBuffer=t.createBuffer({size:e.buffer.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),s.copyBufferToBuffer(e.buffer,0,e.gpuReadBuffer,0,e.buffer.size)}),s.finish()}if(t.queue.submit([f()]),e.results){async function c(t){const r=e.results[t];r.out?(r.phase||0)===a.param&&(await r.gpuReadBuffer.mapAsync(GPUMapMode.READ),r.out(r.gpuReadBuffer.getMappedRange())):console.error("WebGPU: settings.results["+t+"].out is undefined.")}for(;;){for(let t=0;t<e.results.length;t++)await c(t);if(a.param++,a.param>a.max)break;t.queue.writeBuffer(a.paramBuffer,0,new Uint32Array([a.param])),t.queue.submit([f()])}}}l?p(l):loadFile.async(e.shaderCodeFile,{onload:function(e,t){p(e)}})}()}()}}WebGPU.isSupportWebGPU=function(){return"gpu"in navigator},WebGPU.out2Matrix=function(e,t={}){const r=t.type?new t.type(e):new Float32Array(e),s=[];let n,a;const o=t.size;return o?(a=o.length,n=0):(a=r[0],n=a+1),function e(s,i){if(s>a)return;const u=o?o[s-1]:r[s];for(let f=0;f<u;f++){const u=[];if(s===a-1){const e=o?o[a-1]:r[a];for(let t=0;t<e;t++){if(n>=r.length)return void console.error("WebGPU.out2Matrix: out of the index range of the out array. "+n);u.push(r[n]),n++}t.push&&t.push(u)}else e(s+1,u);t.push&&!t.returnMatrix||i.push(u)}}(1,s),s};export default WebGPU;